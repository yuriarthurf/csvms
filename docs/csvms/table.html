<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>csvms.table API documentation</title>
<meta name="description" content="Table Module" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>csvms.table</code></h1>
</header>
<section id="section-intro">
<p>Table Module</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34; Table Module &#34;&#34;&#34;
import json
import re
from csv import reader, writer
from datetime import datetime
from os import remove, makedirs
from os.path import exists
from pathlib import Path
from typing import List, Dict, Any
# Local module
from csvms import logger
from csvms.schema import Database
from csvms.exceptions import ColumnException
from csvms.exceptions import DataException
from csvms.exceptions import TableException

# Init log
log = logger()

def rnm(table:str, column:str) -&gt; str:
    &#34;&#34;&#34;Rename table column

    Parameters
    ----------
    table:`str`
        Table name

    column:`str`
        Column name

    Returns
    ----------
    `str`
        Column renamed
    &#34;&#34;&#34;
    if str(column).find(&#39;.&#39;)!=-1:
        return column
    return f&#34;{table}.{column}&#34;

def _nan_(value:Any) -&gt; bool:
    &#34;&#34;&#34;
    Check for None values

    Parameters
    ----------
    value:`Any`
        The value to check

    Returns
    ----------
    bool:
        False if value is None
    &#34;&#34;&#34;
    if value is None:
        return False
    return value

class Table():
    &#34;&#34;&#34;
    Represents a collection of tuples as table

    Class variables
    ----------
    dtypes : `Dict[str,type]`
        Supported columns data types

    operations : `Dict[str,Callable]`
        Supported operator on selection operations

    functions : `Dict[str,Callable]`
        Supported functions on extended operations

    Attributes
    ----------
    name : `str`
        Table name identifier

    database : `Database`
        Database where the table are located

    columns : `Dict[str,type]`
        Table attributes

    temporary : `bool`
        True if table is temporary.
        Important: Temporary table can&#39;t be save on disk

    &#34;&#34;&#34;
    _FORMAT_=&#34;csv&#34; # Data file format
    _CSVSEP_=&#34;;&#34;   # Separator
    # Supported data types
    dtypes = {
        &#34;string&#34;:str,
        &#34;text&#34;:str,
        &#34;int&#34;:int,
        &#34;integer&#34;:int,
        &#34;float&#34;:float,
        &#34;boolean&#34;:bool}
    # Supported operations
    operations = {
        &#39;lt&#39;     :lambda x,y:_nan_(x) &lt; _nan_(y),
        &#39;gt&#39;     :lambda x,y:_nan_(x) &gt; _nan_(y),
        &#39;eq&#39;     :lambda x,y:_nan_(x) == _nan_(y),
        &#39;lte&#39;    :lambda x,y:_nan_(x) &lt;= _nan_(y),
        &#39;gte&#39;    :lambda x,y:_nan_(x) &gt;= _nan_(y),
        &#39;neq&#39;    :lambda x,y:_nan_(x) != _nan_(y),
        &#39;is&#39;     :lambda x,y:_nan_(x) is _nan_(y),
        &#39;in&#39;     :lambda x,y:_nan_(x) in _nan_(y),
        &#39;nin&#39;    :lambda x,y:_nan_(x) not in _nan_(y),
        &#39;or&#39;     :lambda x,y:_nan_(x) or _nan_(y),
        &#39;and&#39;    :lambda x,y:_nan_(x) and _nan_(y),
        &#39;missing&#39;:lambda   x:x is None,
        &#39;exists&#39; :lambda   x:x is not None}
    # Supported functions
    functions = {
        &#39;add&#39;: lambda x,y: None if x is None or y is None else x+y,
        &#39;sub&#39;: lambda x,y: None if x is None or y is None else x-y,
        &#39;div&#39;: lambda x,y: None if x is None or y is None else x/y,
        &#39;mul&#39;: lambda x,y: None if x is None or y is None else x*y,
        #TODO: Concatenate two string
        #TODO: Raises expr1 to the power of expr2.
    }
    # Supported operations reverse
    _strtypes_ = {value:key for key, value in dtypes.items()}

    def __init__(self, name:str, columns:Dict[str,type]=None,
        data:List[tuple]=None, temp:bool=False):
        &#34;&#34;&#34;
        Table representation and the data file using database location path to store all rows

        Parameters
        ----------
        name : `str`
            Table identifier composed by database name and the table name separated by &#39;.&#39;
            If the database name was omitted, uses the default database instead

        columns : `Dict[str,type]`, `optional`
            Dictionary with columns names and data types. Only python primitive type are alowed.
            If None, load from catalog definition. *Default is None*

            #### Example

            ```
            Table(
                name=&#39;sample&#39;,
                columns={
                    &#39;att1&#39;:str,
                    &#39;att2&#39;:int})
            ```

        data : `List[tuple]`, `optional`
            Load table tuples into table rows. If None load from data file. *Default is None*

            #### Example

            ```
            Table(
                name=&#39;sample&#39;,
                columns={
                    &#39;att1&#39;:str,
                    &#39;att2&#39;:int},
                data=[
                    (&#39;a&#39;,1),
                    (&#39;b&#39;,2)])
            ```

        temp : `bool`, `optional`
            If &#39;False&#39; create datafile, other else the rows will be available only on python memory.
            *Default False*

        &#34;&#34;&#34;
        if data is None:
            data = list()
        self.temporary = temp
        _db = None
        self.name = name
        if name.count(&#39;.&#39;) == 1:
            _db, self.name = name.split(&#39;.&#39;)
        self.database = Database(_db, temp)
        self.columns = columns
        self._rows = data
        if exists(self.location):
            self._rows = list(self.load())
        if self.columns is None:
            raise TableException(&#34;Table not found&#34;)

    @classmethod
    def _op_ts_(cls) -&gt; str:
        &#34;&#34;&#34;
        Get the system date time and format

        Returns
        ----------
        str:
            Return a formatted timestamp
        &#34;&#34;&#34;
        return datetime.today().isoformat().replace(&#39;T&#39;,&#39; &#39;)

    @classmethod
    def _condition_parser_(cls, exp:str) -&gt; List[str]:
        &#34;&#34;&#34;Condition parser

        Parameters
        ----------
        exp:`str`
            String with operation

        Returns
        ----------
        List[str]:
            List with operation name and value
        &#34;&#34;&#34;
        ops = &#39;|&#39;.join(Table.operations.keys())
        match = next(re.finditer(rf&#34;({ops})\s+(.+)&#34;, exp, re.IGNORECASE))
        return [match.group(1), match.group(2)]

    @property
    def full_name(self):
        &#34;&#34;&#34;Return table full name identifier&#34;&#34;&#34;
        return f&#34;{self.database.name}.{self.name}&#34;

    @property
    def definition(self) -&gt; dict:
        &#34;&#34;&#34;Return table definition as dictionary&#34;&#34;&#34;
        return dict(
            name=self.full_name,
            columns = {key: Table._strtypes_[val] for key, val in self.columns.items()}
        )

    @property
    def location(self) -&gt; str:
        &#34;&#34;&#34;Return table location on file system as string&#34;&#34;&#34;
        return f&#34;{self.database.location}/{self.name}.{Table._FORMAT_}&#34;

    @property
    def empty_row(self) -&gt; tuple:
        &#34;&#34;&#34;Return an tuple with &#39;None&#39; values for each column&#34;&#34;&#34;
        return tuple([None for _ in self.columns])

    @property
    def transaction_log(self) -&gt; Path:
        &#34;&#34;&#34;Path to transaction log&#34;&#34;&#34;
        return Path(f&#34;{Database.FILE_DIR}/log/{self.full_name}&#34;)

    def _redo_(self, values:tuple) -&gt; bool:
        &#34;&#34;&#34;Write transaction redo log file&#34;&#34;&#34;
        makedirs(self.transaction_log, exist_ok=True)
        log_file = self.transaction_log.joinpath(&#34;redo&#34;)
        with open(log_file, mode=&#39;a&#39;, encoding=&#34;utf-8&#34;) as redolog:
            writer(redolog).writerow(values)
        return True

    def _value_(self, row:tuple, key:str):
        &#34;&#34;&#34;Get valeu from row by column name if it&#39;s a columnn identifier
        :param row: Row tuple
        :param key: Column identifier
        &#34;&#34;&#34;
        if key in self.columns.keys():
            return row[key]
        return key

    def load(self) -&gt; List[tuple]:
        &#34;&#34;&#34;Load csv file from path with column formats
        :param table_id: Table full name
        :return: Tuple iterator
        &#34;&#34;&#34;
        definition = self.database.catalog[self.full_name]
        self.columns = {key:Table.dtypes[value] for key, value in definition[&#34;columns&#34;].items()}
        with open(self.location, mode=&#39;r&#39;, encoding=&#34;utf-8&#34;) as csv_file:
            for raw in reader(csv_file, delimiter=Table._CSVSEP_):
                row = list()
                for idx, col in enumerate(self.columns.values()):
                    row.append(col(raw[idx]))
                yield tuple(row)

    def save(self) -&gt; bool:
        &#34;&#34;&#34;Write data to file system&#34;&#34;&#34;
        if self.temporary:
            raise TableException(&#34;Can&#39;t save temporary tables&#34;)
        with open(self.location, mode=&#39;w&#39;, encoding=&#34;utf-8&#34;) as csv_file:
            csv_writer = writer(csv_file, delimiter=Table._CSVSEP_, quotechar=&#39;&#34;&#39;)
            for row in self._rows:
                csv_writer.writerow(row)
        self.database.catalog[self.full_name] = self.definition
        return True

    def alter(self, option:str, column:Dict[str,type], new:Dict[str,type]=None) -&gt; &#34;Table&#34;:
        &#34;&#34;&#34;Alter table definitions
        :param option: Accepts ADD, DROP and MODIFY
        :param column: Where to apply alteration
        :param new: New column definition. Only used on MODIFY operations. Default is None
        :return: The new modified table
        &#34;&#34;&#34;
        for key, val in column.items():
            if option.upper() == &#34;ADD&#34;:
                return self._add_column_(key, val)
            if option.upper() == &#34;DROP&#34;:
                return self._drop_column_(key)
            if option.upper() == &#34;MODIFY&#34;:
                if new is None:
                    raise ColumnException(&#34;Need to inform new column definition&#34;)
                return self._modify_column_(key, new)
        raise ColumnException(f&#34;Column {column} not found&#34;)

    def _add_column_(self, name:str, dtype:type) -&gt; &#34;Table&#34;:
        &#34;&#34;&#34;Add new column to table
        :param name: Column name
        :param dtype: Column data type
        :return: The new modified table
        &#34;&#34;&#34;
        self.columns.update({name:dtype}) # Add column definition
        for idx, row in enumerate(self._rows):
            self._rows[idx] = row + (dtype(),) # Add default values
        return self

    def _drop_column_(self, column:str) -&gt; &#34;Table&#34;:
        &#34;&#34;&#34;Drop column from table
        :param key: Column name
        :return: The new modified table
        &#34;&#34;&#34;
        idx = None
        for pos, col in enumerate(self.columns.keys()):
            if col == column:
                idx = pos # Save colum index
                del self.columns[column] # Remove from columns
                break # exit from loop
        if idx is None:
            raise ColumnException(f&#34;Column {column} not found&#34;)
        for pos, row in enumerate(self._rows):
            row = list(row) # Convert to list
            del row[idx] # remove value for column index
            self._rows[pos] = tuple(row) # Update row
        return self

    def _modify_column_(self, name:str, column:Dict[str,type]) -&gt; &#34;Table&#34;:
        &#34;&#34;&#34;Drop column from table
        :param name: Column name
        :param column: New column
        :return: The new modified table
        &#34;&#34;&#34;
        idx = None
        val = next(iter(column.values()))
        for pos, col in enumerate(self.columns.keys()):
            if col == name:
                idx = pos # Save colum index
                self.columns.update(column) # Update definition
                del self.columns[col] # Remove old column
                break # exit from loop
        tmp_rows = self._rows
        try:
            for pos, row in enumerate(self._rows):
                row = list(row)
                row[idx] = val(row[idx]) # Update column value
                self._rows[pos] = tuple(row) # Update row list
        except Exception as err:
            log.debug(err)
            self._rows = tmp_rows
            raise ColumnException(f&#34;Cant change data type for column {name}&#34;)
        return self

    def clean(self) -&gt; bool:
        &#34;&#34;&#34;Remove all table data&#34;&#34;&#34;
        self._rows = list()
        if exists(self.location):
            remove(self.location)
        if not self.temporary:
            Path(self.location).touch()
        return True

    def drop(self) -&gt; bool:
        &#34;&#34;&#34;Remove physical file&#34;&#34;&#34;
        remove(self.location)
        del self.database.catalog[self.full_name]
        return True

    def show(self, size:int=20, trunc:bool=True) -&gt; str:
        &#34;&#34;&#34;Print as pretty table data&#34;&#34;&#34;
        # Ugly code for a pretty table...
        idx_pad = 3
        # Max size of each column
        col_size = dict()
        for _c_ in self.columns:
            col_size[_c_]=len(_c_)+1
            for idx, _ in enumerate(self):
                cols = len(str(self[idx][_c_]))
                if col_size[_c_] &lt; cols:
                    col_size[_c_]= cols
        # Table line separator
        sep = f&#34;{&#39; &#39;:{&#39;&gt;&#39;}{idx_pad}}+&#34;
        for key in self.columns.keys():
            sep += f&#34;{&#39;-&#39;:{&#39;-&#39;}{&#39;&lt;&#39;}{col_size[key]}}+&#34;
        # Table header
        col = f&#34;{&#39; &#39;:{&#39;&gt;&#39;}{idx_pad}}|&#34;
        for key in self.columns.keys():
            if trunc:
                col += f&#34;{key.split(&#39;.&#39;)[-1]:{&#39;&lt;&#39;}{col_size[key]}}|&#34;
            else:
                col += f&#34;{key:{&#39;&lt;&#39;}{col_size[key]}}|&#34;
        # Table rows
        rows = str()
        if len(self) &lt;= size:
            size = len(self)
            for idx in range(size):
                rows += f&#34;{idx:{&#39;&#39;}{&#39;&gt;&#39;}{idx_pad}}|&#34;
                for key, val in self[idx].items():
                    rows += f&#34;{str(val):{&#39;&gt;&#39;}{col_size[key]}}|&#34;
                rows+=&#39;\n&#39;
        else:
            for idx in range(int(size/2)):
                rows += f&#34;{idx:{&#39;&#39;}{&#39;&gt;&#39;}{idx_pad}}|&#34;
                for key, val in self[idx].items():
                    rows += f&#34;{str(val):{&#39;&gt;&#39;}{col_size[key]}}|&#34;
                rows+=&#39;\n&#39;
            # Separator row,
            rows += f&#34;{&#39; &#39;:{&#39;&gt;&#39;}{idx_pad}}|&#34;
            for key in self.columns.keys():
                rows += f&#34;{&#39;...&#39;:{&#39;&#39;}{&#39;&gt;&#39;}{col_size[key]}}|&#34;
            rows+=&#39;\n&#39;
            #reversed rows
            for idx in reversed(range(int(size/2))):
                _idx = len(self)-idx-1
                rows += f&#34;{_idx:{&#39;&#39;}{&#39;&gt;&#39;}{idx_pad}}|&#34;
                for key, val in self[_idx].items():
                    rows += f&#34;{str(val):{&#39;&gt;&#39;}{col_size[key]}}|&#34;
                rows+=&#39;\n&#39;
        tbl = f&#34;TABLE: {self.full_name}\n&#34;
        if len(rows)&gt;0:
            return f&#34;&#34;&#34;{tbl}{sep}\n{col}\n{sep}\n{rows[:-1]}\n{sep}\n&#34;&#34;&#34;
        return f&#34;&#34;&#34;{tbl}{sep}\n{col}\n{sep}\n{sep}\n&#34;&#34;&#34;

    def _validade_(self, value) -&gt; tuple:
        row = tuple()
        try:
            for idx, val in enumerate(self.columns.values()):
                if value[idx] is None:
                    row += (None,)
                else:
                    row += (val(value[idx]),)
            return row
        except IndexError as err:
            log.debug(err)
        except ValueError as err:
            log.debug(err)
        raise DataException(f&#34;Invalid data {value} to row {tuple(self.columns.values())}&#34;)

    def append(self, *values) -&gt; bool:
        &#34;&#34;&#34;Add new row
        :param values: list of values, separated by comma, to insert into
        :return: True if table insertion was succeeded
        &#34;&#34;&#34;
        self._rows.append(self._validade_(values))
        self._redo_((&#39;I&#39;,(Table._op_ts_()))+tuple(values))
        log.info(&#34;Row inserted&#34;)
        return True

    def __setitem__(self, idx:int, value:tuple) -&gt; bool:
        &#34;&#34;&#34;Update row
        :param idx: Index row to update
        :param value: New values to the row
        &#34;&#34;&#34;
        self._rows[idx] = self._validade_(value)
        self._redo_((&#39;U&#39;,(Table._op_ts_()))+tuple(value))
        log.info(&#34;Row updated&#34;)
        return True

    def __delitem__(self, idx) -&gt; None:
        &#34;&#34;&#34;Remove line from table
        :param idx: Row table index to delete
        &#34;&#34;&#34;
        self._redo_((&#39;D&#39;,(Table._op_ts_()))+self._rows[idx])
        del self._rows[idx]
        log.info(&#34;Row deleted&#34;)

    def __getitem__(self, key):
        &#34;&#34;&#34;Return rows as Dict&#34;&#34;&#34;
        try:
            return {n:self._rows[key][i] for i,n in enumerate(self.columns)}
        except IndexError:
            log.debug(&#34;Row %s not found&#34;, key)
            return {col:None for col in self.columns.keys()}

    def __iter__(self):
        &#34;&#34;&#34;Iteration over all rows&#34;&#34;&#34;
        for row in self._rows:
            yield row

    def __len__(self):
        &#34;&#34;&#34;Number of rows&#34;&#34;&#34;
        return len(self._rows)

    def __repr__(self):
        &#34;&#34;&#34;Table definition in JSON format&#34;&#34;&#34;
        return json.dumps(self.definition)

    def __str__(self):
        &#34;&#34;&#34;Pretty table format&#34;&#34;&#34;
        return self.show()

    def extend(self, row:dict, ast:dict):
        &#34;&#34;&#34; Resolve functions recursively
        :param ast: parsed expression
        :return: Calculated value
        &#34;&#34;&#34;
        if isinstance(ast, dict):
            for key, val in ast.items():
                _x_, _y_ = val
                if isinstance(_x_, dict):
                    if _x_.get(&#39;literal&#39;) is None:
                        _x_ = self.extend(row, _x_)
                    else:
                        _x_ = _x_[&#39;literal&#39;]
                if isinstance(_y_, dict):
                    if _y_.get(&#39;literal&#39;) is None:
                        _y_ = self.extend(row, _y_)
                    else:
                        _y_ = _y_[&#39;literal&#39;]
                return Table.functions[key](self._value_(row,_x_),self._value_(row,_y_))
        return ast

    def logical_evaluation(self, row:dict, ast:dict) -&gt; bool:
        &#34;&#34;&#34;Recursively evaluate conditions
        :param ast: Abstract Syntax Tree
        :return: Boolean result
        &#34;&#34;&#34;
        if isinstance(ast, dict):
            for key, val in ast.items():
                if key in [&#39;missing&#39;,&#39;exists&#39;]:
                    return Table.operations[key](self._value_(row,val))
                if len(val)&gt;2: # Multiple conditions with and/or
                    return self.logical_evaluation(row, {key:[val[-2],val[-1]]})
                _x_, _y_ = val
                if isinstance(_x_, dict):
                    if _x_.get(&#39;literal&#39;) is None:
                        _x_ = self.logical_evaluation(row, _x_)
                    else:
                        _x_ = _x_[&#39;literal&#39;]
                if isinstance(_y_, dict):
                    if _y_.get(&#39;literal&#39;) is None:
                        _y_ = self.logical_evaluation(row, _y_)
                    else:
                        _y_ = _y_[&#39;literal&#39;]
                return Table.operations[key](self._value_(row,_x_),self._value_(row,_y_))
        raise DataException(f&#34;Can&#39;t evaluate expression: {ast}&#34;)

    ### Relational Algebra operators ###

    def __add__(self, other:&#34;Table&#34;) -&gt; &#34;Table&#34;:
        &#34;&#34;&#34;Union Operator (∪)&#34;&#34;&#34;
        return Table(
            name = f&#34;({self.name}∪{other.name})&#34;,
            # Copy all columns from self
            columns={k:v for k,v in self.columns.items()},
            # Sum all distinct rows from self and other table
            data= list(dict.fromkeys(self._rows + other._rows)))

    def __mod__(self, other:&#34;Table&#34;) -&gt; &#34;Table&#34;:
        &#34;&#34;&#34;Inserct Operator (∩)&#34;&#34;&#34;
        return Table(
            name = f&#34;({self.name}∩{other.name})&#34;,
            # Copy all columns from self
            columns={k:v for k,v in self.columns.items()},
            # Filter rows of self equal to rows of other
            data=[r for r in self for o in other if r == o])

    def __sub__(self, other:&#34;Table&#34;) -&gt; &#34;Table&#34;:
        &#34;&#34;&#34;Difference Operator (−)&#34;&#34;&#34;
        rows = list() # Create a new list of rows
        for _r_ in self: # For each row in self
            rows.append(_r_) # Add the self rows to the new list
            for _o_ in other: # Check if are any tuple in other table that match
                if _r_ == _o_: # If finds a row in other that are equal to self
                    try:
                        rows.pop() # Remove self rows
                    except IndexError:
                        continue
        return Table(
            name = f&#34;({self.name}−{other.name})&#34;,
            columns={k:v for k,v in self.columns.items()},
            data=rows)

    def __mul__(self, other:&#34;Table&#34;) -&gt; &#34;Table&#34;:
        &#34;&#34;&#34;Times Operator (×)&#34;&#34;&#34;
        # Join the tow sets of columns, and concatenate the table name if needed
        columns = {rnm(self.name,k):v for k, v in self.columns.items()}
        columns.update({rnm(other.name,k):v for k, v in other.columns.items()})
        return Table(
            name = f&#34;({self.name}×{other.name})&#34;,
            # Concatenated columns
            columns=columns,
            # Cartesian product of a set of self rows with a set of other rows
            data=[r+o for r in self for o in other])

    #TODO: Implement DivideBy operator
    # More info: https://en.wikipedia.org/wiki/Relational_algebra#Division_(%C3%B7)

    def π(self, select:list) -&gt; &#34;Table&#34;:
        &#34;&#34;&#34;Projection Operator (π)&#34;&#34;&#34;
        # Create a list of projected columns and your index
        cols = {k:v for k,v in self.columns.items()}
        rows = [v for v in self]
        if select != &#39;*&#39;: #In case of &#39;*&#39; return all columns
            if not isinstance(select, list):
                raise NotImplementedError
            _tc = list() # List of orderd columns and indexes
            for col in select:
                # Get column index
                for _i_,_c_ in enumerate(self.columns.keys()):
                    if col[&#39;value&#39;]==_c_: #When find the column
                        _a_ = _c_
                        if col.get(&#39;name&#39;) is not None:
                            _a_ = col[&#39;name&#39;]
                        _tc.append((_i_,_c_,_a_)) #Add to the list with the index
                        break #Exit from loop when find
                    elif col.get(&#39;name&#39;)==_c_:
                        _a_ = _c_ = col[&#39;name&#39;]
                        _tc.append((_i_,_c_,_a_)) #Add to the list with the index
            if len(_tc)!=len(select):
                raise ColumnException(&#34;Cant find all columns&#34;)
            rows = list()
            for row in self: # For each row
                _r_ = tuple() # Create a new tuple
                for idx,_,_ in _tc: # For each projected column
                    _r_ += (row[idx],) # Add values for projected column index
                rows.append(_r_) # Append the new sub tuple to the new list of rows
            cols = {a:self.columns[k] for _,k,a in _tc}
        return Table(name=f&#34;({self.name}π)&#34;,columns=cols,data=rows)

    def σ(self, condition:Dict[str,list], null=False) -&gt; &#34;Table&#34;:
        &#34;&#34;&#34;Selection Operator (σ)
        :param condition: A expression composed by the logic operation and list of values.
                          See &#39;operations&#39; dictionary to get the list of valid options
        ### Exemples

        where id &lt; 2
        `where({&#39;lt&#39;:[&#39;id&#39;,2]})`

        where val = &#39;George&#39; and id &gt; 1
        `where({&#39;and&#39;:[{&#34;eq&#34;:[&#39;val&#39;,&#39;George&#39;]},{&#34;gt&#34;:[&#39;id&#39;,1]}]})`

        ### Operations
        List of supported operations and the logical equivalent python evaluation

        | Name    | Python eval |
        |---------|-------------|
        | lt      | &lt;           |
        | gt      | &gt;           |
        | eq      | ==          |
        | lte     | &lt;=          |
        | gte     | &gt;=          |
        | neq     | !=          |
        | is      | is          |
        | in      | in          |
        | nin     | not in      |
        | or      | or          |
        | and     | and         |
        | missing | is None     |
        | exists  | is not None |

        &#34;&#34;&#34;
        rows = list()
        for idx, row in enumerate(self):
            if self.logical_evaluation(self[idx], condition):
                rows.append(row)
        if null and len(rows)==0:
            rows.append(self.empty_row)
        return Table(
            name = f&#34;({self.name}σ)&#34;,
            columns={k:v for k,v in self.columns.items()},
            data=rows)

    def ᐅᐊ(self, other:&#34;Table&#34;, where:Dict[str,list]) -&gt; &#34;Table&#34;:
        &#34;&#34;&#34;Join Operator (⋈)&#34;&#34;&#34;
        # Create a new table with the Cartesian product of self and otther
        tbl = (self * other)\
            .σ(where) # And select rows where the join condition is true
        tbl.name = f&#34;({self.name}⋈{other.name})&#34;
        return tbl

    def ρ(self, alias:str) -&gt; &#34;Table&#34;:
        &#34;&#34;&#34;Rename Operator (ρ)&#34;&#34;&#34;
        # Function to rename column names for the new table name
        rename = lambda x: x if x.count(&#39;.&#39;)==0 else x.split(&#39;.&#39;)[-1]
        return Table(
            # Set new table name
            name = f&#34;{alias}&#34;,
            # Copy all columns from source table
            columns={rename(k):v for k,v in self.columns.items()},
            # Copy all rows from source table
            data=[r for r in self])

    def Π(self, extend:dict, alias:str=None) -&gt; &#34;Table&#34;:
        &#34;&#34;&#34;Extended projection Operator (Π)&#34;&#34;&#34;
        rows = list() # New list of rows
        dtype = None # Use to store the data type of the new extended column
        for idx, row in enumerate(self): # For each row
            val = self.extend(self[idx],extend) # Evaluated expression
            if dtype is None: # If is the first evaluation
                dtype = type(val) # Use the result data type
            # if you find any different type in the next rows
            elif dtype != type(val) and val is not None:
                # Raise an Data exeption to abort the operation
                raise DataException(f&#34;{type(val)} error&#34;)
            # If Successful add new value to the row tuple
            rows.append(row + (val,))
        # Copy the columns from source table
        cols = {k:v for k,v in self.columns.items()}
        # Add new extended column
        if alias is None: # Remova some characters and use the expression as column name
            cols[f&#34;{str(extend).replace(&#39; &#39;,&#39;&#39;).replace(&#39;.&#39;,&#39;,&#39;)}&#34;]=dtype
        else: # Use alias for the new extended column
            cols[alias]=dtype
        return Table(
            name = f&#34;({self.name}Π)&#34;,
            columns=cols,
            data=rows)

    #TODO: Implement FULL join operator `ᗌᗏ`
    #TODO: Implement LEFT SEMI join operator `ᐅᐸ`
    #TODO: Implement RIGHT SEMI join operator `ᐳᐊ`
    #TODO: Implement LEFT ANTI join operator `ᐅ`
    #TODO: Implement RIGHT ANTI join operator `◁`</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="csvms.table.rnm"><code class="name flex">
<span>def <span class="ident">rnm</span></span>(<span>table: str, column: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Rename table column</p>
<h2 id="parameters">Parameters</h2>
<p>table:<code>str</code>
Table name</p>
<p>column:<code>str</code>
Column name</p>
<h2 id="returns">Returns</h2>
<p><code>str</code>
Column renamed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rnm(table:str, column:str) -&gt; str:
    &#34;&#34;&#34;Rename table column

    Parameters
    ----------
    table:`str`
        Table name

    column:`str`
        Column name

    Returns
    ----------
    `str`
        Column renamed
    &#34;&#34;&#34;
    if str(column).find(&#39;.&#39;)!=-1:
        return column
    return f&#34;{table}.{column}&#34;</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="csvms.table.Table"><code class="flex name class">
<span>class <span class="ident">Table</span></span>
<span>(</span><span>name: str, columns: Dict[str, type] = None, data: List[tuple] = None, temp: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a collection of tuples as table</p>
<h2 id="class-variables">Class Variables</h2>
<p>dtypes : <code>Dict[str,type]</code>
Supported columns data types</p>
<p>operations : <code>Dict[str,Callable]</code>
Supported operator on selection operations</p>
<p>functions : <code>Dict[str,Callable]</code>
Supported functions on extended operations</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Table name identifier</dd>
<dt><strong><code>database</code></strong> :&ensp;<code>Database</code></dt>
<dd>Database where the table are located</dd>
<dt><strong><code>columns</code></strong> :&ensp;<code>Dict[str,type]</code></dt>
<dd>Table attributes</dd>
<dt><strong><code>temporary</code></strong> :&ensp;<code>bool</code></dt>
<dd>True if table is temporary.
Important: Temporary table can't be save on disk</dd>
</dl>
<p>Table representation and the data file using database location path to store all rows</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Table identifier composed by database name and the table name separated by '.'
If the database name was omitted, uses the default database instead</dd>
<dt><strong><code>columns</code></strong> :&ensp;<code>Dict[str,type]<code>,</code>optional</code></dt>
<dd>
<p>Dictionary with columns names and data types. Only python primitive type are alowed.
If None, load from catalog definition. <em>Default is None</em></p>
<h4 id="example">Example</h4>
<p><code>Table(
name='sample',
columns={
'att1':str,
'att2':int})</code></p>
</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>List[tuple]<code>,</code>optional</code></dt>
<dd>
<p>Load table tuples into table rows. If None load from data file. <em>Default is None</em></p>
<h4 id="example_1">Example</h4>
<p><code>Table(
name='sample',
columns={
'att1':str,
'att2':int},
data=[
('a',1),
('b',2)])</code></p>
</dd>
<dt><strong><code>temp</code></strong> :&ensp;<code>bool<code>,</code>optional</code></dt>
<dd>If 'False' create datafile, other else the rows will be available only on python memory.
<em>Default False</em></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Table():
    &#34;&#34;&#34;
    Represents a collection of tuples as table

    Class variables
    ----------
    dtypes : `Dict[str,type]`
        Supported columns data types

    operations : `Dict[str,Callable]`
        Supported operator on selection operations

    functions : `Dict[str,Callable]`
        Supported functions on extended operations

    Attributes
    ----------
    name : `str`
        Table name identifier

    database : `Database`
        Database where the table are located

    columns : `Dict[str,type]`
        Table attributes

    temporary : `bool`
        True if table is temporary.
        Important: Temporary table can&#39;t be save on disk

    &#34;&#34;&#34;
    _FORMAT_=&#34;csv&#34; # Data file format
    _CSVSEP_=&#34;;&#34;   # Separator
    # Supported data types
    dtypes = {
        &#34;string&#34;:str,
        &#34;text&#34;:str,
        &#34;int&#34;:int,
        &#34;integer&#34;:int,
        &#34;float&#34;:float,
        &#34;boolean&#34;:bool}
    # Supported operations
    operations = {
        &#39;lt&#39;     :lambda x,y:_nan_(x) &lt; _nan_(y),
        &#39;gt&#39;     :lambda x,y:_nan_(x) &gt; _nan_(y),
        &#39;eq&#39;     :lambda x,y:_nan_(x) == _nan_(y),
        &#39;lte&#39;    :lambda x,y:_nan_(x) &lt;= _nan_(y),
        &#39;gte&#39;    :lambda x,y:_nan_(x) &gt;= _nan_(y),
        &#39;neq&#39;    :lambda x,y:_nan_(x) != _nan_(y),
        &#39;is&#39;     :lambda x,y:_nan_(x) is _nan_(y),
        &#39;in&#39;     :lambda x,y:_nan_(x) in _nan_(y),
        &#39;nin&#39;    :lambda x,y:_nan_(x) not in _nan_(y),
        &#39;or&#39;     :lambda x,y:_nan_(x) or _nan_(y),
        &#39;and&#39;    :lambda x,y:_nan_(x) and _nan_(y),
        &#39;missing&#39;:lambda   x:x is None,
        &#39;exists&#39; :lambda   x:x is not None}
    # Supported functions
    functions = {
        &#39;add&#39;: lambda x,y: None if x is None or y is None else x+y,
        &#39;sub&#39;: lambda x,y: None if x is None or y is None else x-y,
        &#39;div&#39;: lambda x,y: None if x is None or y is None else x/y,
        &#39;mul&#39;: lambda x,y: None if x is None or y is None else x*y,
        #TODO: Concatenate two string
        #TODO: Raises expr1 to the power of expr2.
    }
    # Supported operations reverse
    _strtypes_ = {value:key for key, value in dtypes.items()}

    def __init__(self, name:str, columns:Dict[str,type]=None,
        data:List[tuple]=None, temp:bool=False):
        &#34;&#34;&#34;
        Table representation and the data file using database location path to store all rows

        Parameters
        ----------
        name : `str`
            Table identifier composed by database name and the table name separated by &#39;.&#39;
            If the database name was omitted, uses the default database instead

        columns : `Dict[str,type]`, `optional`
            Dictionary with columns names and data types. Only python primitive type are alowed.
            If None, load from catalog definition. *Default is None*

            #### Example

            ```
            Table(
                name=&#39;sample&#39;,
                columns={
                    &#39;att1&#39;:str,
                    &#39;att2&#39;:int})
            ```

        data : `List[tuple]`, `optional`
            Load table tuples into table rows. If None load from data file. *Default is None*

            #### Example

            ```
            Table(
                name=&#39;sample&#39;,
                columns={
                    &#39;att1&#39;:str,
                    &#39;att2&#39;:int},
                data=[
                    (&#39;a&#39;,1),
                    (&#39;b&#39;,2)])
            ```

        temp : `bool`, `optional`
            If &#39;False&#39; create datafile, other else the rows will be available only on python memory.
            *Default False*

        &#34;&#34;&#34;
        if data is None:
            data = list()
        self.temporary = temp
        _db = None
        self.name = name
        if name.count(&#39;.&#39;) == 1:
            _db, self.name = name.split(&#39;.&#39;)
        self.database = Database(_db, temp)
        self.columns = columns
        self._rows = data
        if exists(self.location):
            self._rows = list(self.load())
        if self.columns is None:
            raise TableException(&#34;Table not found&#34;)

    @classmethod
    def _op_ts_(cls) -&gt; str:
        &#34;&#34;&#34;
        Get the system date time and format

        Returns
        ----------
        str:
            Return a formatted timestamp
        &#34;&#34;&#34;
        return datetime.today().isoformat().replace(&#39;T&#39;,&#39; &#39;)

    @classmethod
    def _condition_parser_(cls, exp:str) -&gt; List[str]:
        &#34;&#34;&#34;Condition parser

        Parameters
        ----------
        exp:`str`
            String with operation

        Returns
        ----------
        List[str]:
            List with operation name and value
        &#34;&#34;&#34;
        ops = &#39;|&#39;.join(Table.operations.keys())
        match = next(re.finditer(rf&#34;({ops})\s+(.+)&#34;, exp, re.IGNORECASE))
        return [match.group(1), match.group(2)]

    @property
    def full_name(self):
        &#34;&#34;&#34;Return table full name identifier&#34;&#34;&#34;
        return f&#34;{self.database.name}.{self.name}&#34;

    @property
    def definition(self) -&gt; dict:
        &#34;&#34;&#34;Return table definition as dictionary&#34;&#34;&#34;
        return dict(
            name=self.full_name,
            columns = {key: Table._strtypes_[val] for key, val in self.columns.items()}
        )

    @property
    def location(self) -&gt; str:
        &#34;&#34;&#34;Return table location on file system as string&#34;&#34;&#34;
        return f&#34;{self.database.location}/{self.name}.{Table._FORMAT_}&#34;

    @property
    def empty_row(self) -&gt; tuple:
        &#34;&#34;&#34;Return an tuple with &#39;None&#39; values for each column&#34;&#34;&#34;
        return tuple([None for _ in self.columns])

    @property
    def transaction_log(self) -&gt; Path:
        &#34;&#34;&#34;Path to transaction log&#34;&#34;&#34;
        return Path(f&#34;{Database.FILE_DIR}/log/{self.full_name}&#34;)

    def _redo_(self, values:tuple) -&gt; bool:
        &#34;&#34;&#34;Write transaction redo log file&#34;&#34;&#34;
        makedirs(self.transaction_log, exist_ok=True)
        log_file = self.transaction_log.joinpath(&#34;redo&#34;)
        with open(log_file, mode=&#39;a&#39;, encoding=&#34;utf-8&#34;) as redolog:
            writer(redolog).writerow(values)
        return True

    def _value_(self, row:tuple, key:str):
        &#34;&#34;&#34;Get valeu from row by column name if it&#39;s a columnn identifier
        :param row: Row tuple
        :param key: Column identifier
        &#34;&#34;&#34;
        if key in self.columns.keys():
            return row[key]
        return key

    def load(self) -&gt; List[tuple]:
        &#34;&#34;&#34;Load csv file from path with column formats
        :param table_id: Table full name
        :return: Tuple iterator
        &#34;&#34;&#34;
        definition = self.database.catalog[self.full_name]
        self.columns = {key:Table.dtypes[value] for key, value in definition[&#34;columns&#34;].items()}
        with open(self.location, mode=&#39;r&#39;, encoding=&#34;utf-8&#34;) as csv_file:
            for raw in reader(csv_file, delimiter=Table._CSVSEP_):
                row = list()
                for idx, col in enumerate(self.columns.values()):
                    row.append(col(raw[idx]))
                yield tuple(row)

    def save(self) -&gt; bool:
        &#34;&#34;&#34;Write data to file system&#34;&#34;&#34;
        if self.temporary:
            raise TableException(&#34;Can&#39;t save temporary tables&#34;)
        with open(self.location, mode=&#39;w&#39;, encoding=&#34;utf-8&#34;) as csv_file:
            csv_writer = writer(csv_file, delimiter=Table._CSVSEP_, quotechar=&#39;&#34;&#39;)
            for row in self._rows:
                csv_writer.writerow(row)
        self.database.catalog[self.full_name] = self.definition
        return True

    def alter(self, option:str, column:Dict[str,type], new:Dict[str,type]=None) -&gt; &#34;Table&#34;:
        &#34;&#34;&#34;Alter table definitions
        :param option: Accepts ADD, DROP and MODIFY
        :param column: Where to apply alteration
        :param new: New column definition. Only used on MODIFY operations. Default is None
        :return: The new modified table
        &#34;&#34;&#34;
        for key, val in column.items():
            if option.upper() == &#34;ADD&#34;:
                return self._add_column_(key, val)
            if option.upper() == &#34;DROP&#34;:
                return self._drop_column_(key)
            if option.upper() == &#34;MODIFY&#34;:
                if new is None:
                    raise ColumnException(&#34;Need to inform new column definition&#34;)
                return self._modify_column_(key, new)
        raise ColumnException(f&#34;Column {column} not found&#34;)

    def _add_column_(self, name:str, dtype:type) -&gt; &#34;Table&#34;:
        &#34;&#34;&#34;Add new column to table
        :param name: Column name
        :param dtype: Column data type
        :return: The new modified table
        &#34;&#34;&#34;
        self.columns.update({name:dtype}) # Add column definition
        for idx, row in enumerate(self._rows):
            self._rows[idx] = row + (dtype(),) # Add default values
        return self

    def _drop_column_(self, column:str) -&gt; &#34;Table&#34;:
        &#34;&#34;&#34;Drop column from table
        :param key: Column name
        :return: The new modified table
        &#34;&#34;&#34;
        idx = None
        for pos, col in enumerate(self.columns.keys()):
            if col == column:
                idx = pos # Save colum index
                del self.columns[column] # Remove from columns
                break # exit from loop
        if idx is None:
            raise ColumnException(f&#34;Column {column} not found&#34;)
        for pos, row in enumerate(self._rows):
            row = list(row) # Convert to list
            del row[idx] # remove value for column index
            self._rows[pos] = tuple(row) # Update row
        return self

    def _modify_column_(self, name:str, column:Dict[str,type]) -&gt; &#34;Table&#34;:
        &#34;&#34;&#34;Drop column from table
        :param name: Column name
        :param column: New column
        :return: The new modified table
        &#34;&#34;&#34;
        idx = None
        val = next(iter(column.values()))
        for pos, col in enumerate(self.columns.keys()):
            if col == name:
                idx = pos # Save colum index
                self.columns.update(column) # Update definition
                del self.columns[col] # Remove old column
                break # exit from loop
        tmp_rows = self._rows
        try:
            for pos, row in enumerate(self._rows):
                row = list(row)
                row[idx] = val(row[idx]) # Update column value
                self._rows[pos] = tuple(row) # Update row list
        except Exception as err:
            log.debug(err)
            self._rows = tmp_rows
            raise ColumnException(f&#34;Cant change data type for column {name}&#34;)
        return self

    def clean(self) -&gt; bool:
        &#34;&#34;&#34;Remove all table data&#34;&#34;&#34;
        self._rows = list()
        if exists(self.location):
            remove(self.location)
        if not self.temporary:
            Path(self.location).touch()
        return True

    def drop(self) -&gt; bool:
        &#34;&#34;&#34;Remove physical file&#34;&#34;&#34;
        remove(self.location)
        del self.database.catalog[self.full_name]
        return True

    def show(self, size:int=20, trunc:bool=True) -&gt; str:
        &#34;&#34;&#34;Print as pretty table data&#34;&#34;&#34;
        # Ugly code for a pretty table...
        idx_pad = 3
        # Max size of each column
        col_size = dict()
        for _c_ in self.columns:
            col_size[_c_]=len(_c_)+1
            for idx, _ in enumerate(self):
                cols = len(str(self[idx][_c_]))
                if col_size[_c_] &lt; cols:
                    col_size[_c_]= cols
        # Table line separator
        sep = f&#34;{&#39; &#39;:{&#39;&gt;&#39;}{idx_pad}}+&#34;
        for key in self.columns.keys():
            sep += f&#34;{&#39;-&#39;:{&#39;-&#39;}{&#39;&lt;&#39;}{col_size[key]}}+&#34;
        # Table header
        col = f&#34;{&#39; &#39;:{&#39;&gt;&#39;}{idx_pad}}|&#34;
        for key in self.columns.keys():
            if trunc:
                col += f&#34;{key.split(&#39;.&#39;)[-1]:{&#39;&lt;&#39;}{col_size[key]}}|&#34;
            else:
                col += f&#34;{key:{&#39;&lt;&#39;}{col_size[key]}}|&#34;
        # Table rows
        rows = str()
        if len(self) &lt;= size:
            size = len(self)
            for idx in range(size):
                rows += f&#34;{idx:{&#39;&#39;}{&#39;&gt;&#39;}{idx_pad}}|&#34;
                for key, val in self[idx].items():
                    rows += f&#34;{str(val):{&#39;&gt;&#39;}{col_size[key]}}|&#34;
                rows+=&#39;\n&#39;
        else:
            for idx in range(int(size/2)):
                rows += f&#34;{idx:{&#39;&#39;}{&#39;&gt;&#39;}{idx_pad}}|&#34;
                for key, val in self[idx].items():
                    rows += f&#34;{str(val):{&#39;&gt;&#39;}{col_size[key]}}|&#34;
                rows+=&#39;\n&#39;
            # Separator row,
            rows += f&#34;{&#39; &#39;:{&#39;&gt;&#39;}{idx_pad}}|&#34;
            for key in self.columns.keys():
                rows += f&#34;{&#39;...&#39;:{&#39;&#39;}{&#39;&gt;&#39;}{col_size[key]}}|&#34;
            rows+=&#39;\n&#39;
            #reversed rows
            for idx in reversed(range(int(size/2))):
                _idx = len(self)-idx-1
                rows += f&#34;{_idx:{&#39;&#39;}{&#39;&gt;&#39;}{idx_pad}}|&#34;
                for key, val in self[_idx].items():
                    rows += f&#34;{str(val):{&#39;&gt;&#39;}{col_size[key]}}|&#34;
                rows+=&#39;\n&#39;
        tbl = f&#34;TABLE: {self.full_name}\n&#34;
        if len(rows)&gt;0:
            return f&#34;&#34;&#34;{tbl}{sep}\n{col}\n{sep}\n{rows[:-1]}\n{sep}\n&#34;&#34;&#34;
        return f&#34;&#34;&#34;{tbl}{sep}\n{col}\n{sep}\n{sep}\n&#34;&#34;&#34;

    def _validade_(self, value) -&gt; tuple:
        row = tuple()
        try:
            for idx, val in enumerate(self.columns.values()):
                if value[idx] is None:
                    row += (None,)
                else:
                    row += (val(value[idx]),)
            return row
        except IndexError as err:
            log.debug(err)
        except ValueError as err:
            log.debug(err)
        raise DataException(f&#34;Invalid data {value} to row {tuple(self.columns.values())}&#34;)

    def append(self, *values) -&gt; bool:
        &#34;&#34;&#34;Add new row
        :param values: list of values, separated by comma, to insert into
        :return: True if table insertion was succeeded
        &#34;&#34;&#34;
        self._rows.append(self._validade_(values))
        self._redo_((&#39;I&#39;,(Table._op_ts_()))+tuple(values))
        log.info(&#34;Row inserted&#34;)
        return True

    def __setitem__(self, idx:int, value:tuple) -&gt; bool:
        &#34;&#34;&#34;Update row
        :param idx: Index row to update
        :param value: New values to the row
        &#34;&#34;&#34;
        self._rows[idx] = self._validade_(value)
        self._redo_((&#39;U&#39;,(Table._op_ts_()))+tuple(value))
        log.info(&#34;Row updated&#34;)
        return True

    def __delitem__(self, idx) -&gt; None:
        &#34;&#34;&#34;Remove line from table
        :param idx: Row table index to delete
        &#34;&#34;&#34;
        self._redo_((&#39;D&#39;,(Table._op_ts_()))+self._rows[idx])
        del self._rows[idx]
        log.info(&#34;Row deleted&#34;)

    def __getitem__(self, key):
        &#34;&#34;&#34;Return rows as Dict&#34;&#34;&#34;
        try:
            return {n:self._rows[key][i] for i,n in enumerate(self.columns)}
        except IndexError:
            log.debug(&#34;Row %s not found&#34;, key)
            return {col:None for col in self.columns.keys()}

    def __iter__(self):
        &#34;&#34;&#34;Iteration over all rows&#34;&#34;&#34;
        for row in self._rows:
            yield row

    def __len__(self):
        &#34;&#34;&#34;Number of rows&#34;&#34;&#34;
        return len(self._rows)

    def __repr__(self):
        &#34;&#34;&#34;Table definition in JSON format&#34;&#34;&#34;
        return json.dumps(self.definition)

    def __str__(self):
        &#34;&#34;&#34;Pretty table format&#34;&#34;&#34;
        return self.show()

    def extend(self, row:dict, ast:dict):
        &#34;&#34;&#34; Resolve functions recursively
        :param ast: parsed expression
        :return: Calculated value
        &#34;&#34;&#34;
        if isinstance(ast, dict):
            for key, val in ast.items():
                _x_, _y_ = val
                if isinstance(_x_, dict):
                    if _x_.get(&#39;literal&#39;) is None:
                        _x_ = self.extend(row, _x_)
                    else:
                        _x_ = _x_[&#39;literal&#39;]
                if isinstance(_y_, dict):
                    if _y_.get(&#39;literal&#39;) is None:
                        _y_ = self.extend(row, _y_)
                    else:
                        _y_ = _y_[&#39;literal&#39;]
                return Table.functions[key](self._value_(row,_x_),self._value_(row,_y_))
        return ast

    def logical_evaluation(self, row:dict, ast:dict) -&gt; bool:
        &#34;&#34;&#34;Recursively evaluate conditions
        :param ast: Abstract Syntax Tree
        :return: Boolean result
        &#34;&#34;&#34;
        if isinstance(ast, dict):
            for key, val in ast.items():
                if key in [&#39;missing&#39;,&#39;exists&#39;]:
                    return Table.operations[key](self._value_(row,val))
                if len(val)&gt;2: # Multiple conditions with and/or
                    return self.logical_evaluation(row, {key:[val[-2],val[-1]]})
                _x_, _y_ = val
                if isinstance(_x_, dict):
                    if _x_.get(&#39;literal&#39;) is None:
                        _x_ = self.logical_evaluation(row, _x_)
                    else:
                        _x_ = _x_[&#39;literal&#39;]
                if isinstance(_y_, dict):
                    if _y_.get(&#39;literal&#39;) is None:
                        _y_ = self.logical_evaluation(row, _y_)
                    else:
                        _y_ = _y_[&#39;literal&#39;]
                return Table.operations[key](self._value_(row,_x_),self._value_(row,_y_))
        raise DataException(f&#34;Can&#39;t evaluate expression: {ast}&#34;)

    ### Relational Algebra operators ###

    def __add__(self, other:&#34;Table&#34;) -&gt; &#34;Table&#34;:
        &#34;&#34;&#34;Union Operator (∪)&#34;&#34;&#34;
        return Table(
            name = f&#34;({self.name}∪{other.name})&#34;,
            # Copy all columns from self
            columns={k:v for k,v in self.columns.items()},
            # Sum all distinct rows from self and other table
            data= list(dict.fromkeys(self._rows + other._rows)))

    def __mod__(self, other:&#34;Table&#34;) -&gt; &#34;Table&#34;:
        &#34;&#34;&#34;Inserct Operator (∩)&#34;&#34;&#34;
        return Table(
            name = f&#34;({self.name}∩{other.name})&#34;,
            # Copy all columns from self
            columns={k:v for k,v in self.columns.items()},
            # Filter rows of self equal to rows of other
            data=[r for r in self for o in other if r == o])

    def __sub__(self, other:&#34;Table&#34;) -&gt; &#34;Table&#34;:
        &#34;&#34;&#34;Difference Operator (−)&#34;&#34;&#34;
        rows = list() # Create a new list of rows
        for _r_ in self: # For each row in self
            rows.append(_r_) # Add the self rows to the new list
            for _o_ in other: # Check if are any tuple in other table that match
                if _r_ == _o_: # If finds a row in other that are equal to self
                    try:
                        rows.pop() # Remove self rows
                    except IndexError:
                        continue
        return Table(
            name = f&#34;({self.name}−{other.name})&#34;,
            columns={k:v for k,v in self.columns.items()},
            data=rows)

    def __mul__(self, other:&#34;Table&#34;) -&gt; &#34;Table&#34;:
        &#34;&#34;&#34;Times Operator (×)&#34;&#34;&#34;
        # Join the tow sets of columns, and concatenate the table name if needed
        columns = {rnm(self.name,k):v for k, v in self.columns.items()}
        columns.update({rnm(other.name,k):v for k, v in other.columns.items()})
        return Table(
            name = f&#34;({self.name}×{other.name})&#34;,
            # Concatenated columns
            columns=columns,
            # Cartesian product of a set of self rows with a set of other rows
            data=[r+o for r in self for o in other])

    #TODO: Implement DivideBy operator
    # More info: https://en.wikipedia.org/wiki/Relational_algebra#Division_(%C3%B7)

    def π(self, select:list) -&gt; &#34;Table&#34;:
        &#34;&#34;&#34;Projection Operator (π)&#34;&#34;&#34;
        # Create a list of projected columns and your index
        cols = {k:v for k,v in self.columns.items()}
        rows = [v for v in self]
        if select != &#39;*&#39;: #In case of &#39;*&#39; return all columns
            if not isinstance(select, list):
                raise NotImplementedError
            _tc = list() # List of orderd columns and indexes
            for col in select:
                # Get column index
                for _i_,_c_ in enumerate(self.columns.keys()):
                    if col[&#39;value&#39;]==_c_: #When find the column
                        _a_ = _c_
                        if col.get(&#39;name&#39;) is not None:
                            _a_ = col[&#39;name&#39;]
                        _tc.append((_i_,_c_,_a_)) #Add to the list with the index
                        break #Exit from loop when find
                    elif col.get(&#39;name&#39;)==_c_:
                        _a_ = _c_ = col[&#39;name&#39;]
                        _tc.append((_i_,_c_,_a_)) #Add to the list with the index
            if len(_tc)!=len(select):
                raise ColumnException(&#34;Cant find all columns&#34;)
            rows = list()
            for row in self: # For each row
                _r_ = tuple() # Create a new tuple
                for idx,_,_ in _tc: # For each projected column
                    _r_ += (row[idx],) # Add values for projected column index
                rows.append(_r_) # Append the new sub tuple to the new list of rows
            cols = {a:self.columns[k] for _,k,a in _tc}
        return Table(name=f&#34;({self.name}π)&#34;,columns=cols,data=rows)

    def σ(self, condition:Dict[str,list], null=False) -&gt; &#34;Table&#34;:
        &#34;&#34;&#34;Selection Operator (σ)
        :param condition: A expression composed by the logic operation and list of values.
                          See &#39;operations&#39; dictionary to get the list of valid options
        ### Exemples

        where id &lt; 2
        `where({&#39;lt&#39;:[&#39;id&#39;,2]})`

        where val = &#39;George&#39; and id &gt; 1
        `where({&#39;and&#39;:[{&#34;eq&#34;:[&#39;val&#39;,&#39;George&#39;]},{&#34;gt&#34;:[&#39;id&#39;,1]}]})`

        ### Operations
        List of supported operations and the logical equivalent python evaluation

        | Name    | Python eval |
        |---------|-------------|
        | lt      | &lt;           |
        | gt      | &gt;           |
        | eq      | ==          |
        | lte     | &lt;=          |
        | gte     | &gt;=          |
        | neq     | !=          |
        | is      | is          |
        | in      | in          |
        | nin     | not in      |
        | or      | or          |
        | and     | and         |
        | missing | is None     |
        | exists  | is not None |

        &#34;&#34;&#34;
        rows = list()
        for idx, row in enumerate(self):
            if self.logical_evaluation(self[idx], condition):
                rows.append(row)
        if null and len(rows)==0:
            rows.append(self.empty_row)
        return Table(
            name = f&#34;({self.name}σ)&#34;,
            columns={k:v for k,v in self.columns.items()},
            data=rows)

    def ᐅᐊ(self, other:&#34;Table&#34;, where:Dict[str,list]) -&gt; &#34;Table&#34;:
        &#34;&#34;&#34;Join Operator (⋈)&#34;&#34;&#34;
        # Create a new table with the Cartesian product of self and otther
        tbl = (self * other)\
            .σ(where) # And select rows where the join condition is true
        tbl.name = f&#34;({self.name}⋈{other.name})&#34;
        return tbl

    def ρ(self, alias:str) -&gt; &#34;Table&#34;:
        &#34;&#34;&#34;Rename Operator (ρ)&#34;&#34;&#34;
        # Function to rename column names for the new table name
        rename = lambda x: x if x.count(&#39;.&#39;)==0 else x.split(&#39;.&#39;)[-1]
        return Table(
            # Set new table name
            name = f&#34;{alias}&#34;,
            # Copy all columns from source table
            columns={rename(k):v for k,v in self.columns.items()},
            # Copy all rows from source table
            data=[r for r in self])

    def Π(self, extend:dict, alias:str=None) -&gt; &#34;Table&#34;:
        &#34;&#34;&#34;Extended projection Operator (Π)&#34;&#34;&#34;
        rows = list() # New list of rows
        dtype = None # Use to store the data type of the new extended column
        for idx, row in enumerate(self): # For each row
            val = self.extend(self[idx],extend) # Evaluated expression
            if dtype is None: # If is the first evaluation
                dtype = type(val) # Use the result data type
            # if you find any different type in the next rows
            elif dtype != type(val) and val is not None:
                # Raise an Data exeption to abort the operation
                raise DataException(f&#34;{type(val)} error&#34;)
            # If Successful add new value to the row tuple
            rows.append(row + (val,))
        # Copy the columns from source table
        cols = {k:v for k,v in self.columns.items()}
        # Add new extended column
        if alias is None: # Remova some characters and use the expression as column name
            cols[f&#34;{str(extend).replace(&#39; &#39;,&#39;&#39;).replace(&#39;.&#39;,&#39;,&#39;)}&#34;]=dtype
        else: # Use alias for the new extended column
            cols[alias]=dtype
        return Table(
            name = f&#34;({self.name}Π)&#34;,
            columns=cols,
            data=rows)

    #TODO: Implement FULL join operator `ᗌᗏ`
    #TODO: Implement LEFT SEMI join operator `ᐅᐸ`
    #TODO: Implement RIGHT SEMI join operator `ᐳᐊ`
    #TODO: Implement LEFT ANTI join operator `ᐅ`
    #TODO: Implement RIGHT ANTI join operator `◁`</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="csvms.table.Table.dtypes"><code class="name">var <span class="ident">dtypes</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="csvms.table.Table.functions"><code class="name">var <span class="ident">functions</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="csvms.table.Table.operations"><code class="name">var <span class="ident">operations</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="csvms.table.Table.definition"><code class="name">var <span class="ident">definition</span> : dict</code></dt>
<dd>
<div class="desc"><p>Return table definition as dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def definition(self) -&gt; dict:
    &#34;&#34;&#34;Return table definition as dictionary&#34;&#34;&#34;
    return dict(
        name=self.full_name,
        columns = {key: Table._strtypes_[val] for key, val in self.columns.items()}
    )</code></pre>
</details>
</dd>
<dt id="csvms.table.Table.empty_row"><code class="name">var <span class="ident">empty_row</span> : tuple</code></dt>
<dd>
<div class="desc"><p>Return an tuple with 'None' values for each column</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def empty_row(self) -&gt; tuple:
    &#34;&#34;&#34;Return an tuple with &#39;None&#39; values for each column&#34;&#34;&#34;
    return tuple([None for _ in self.columns])</code></pre>
</details>
</dd>
<dt id="csvms.table.Table.full_name"><code class="name">var <span class="ident">full_name</span></code></dt>
<dd>
<div class="desc"><p>Return table full name identifier</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def full_name(self):
    &#34;&#34;&#34;Return table full name identifier&#34;&#34;&#34;
    return f&#34;{self.database.name}.{self.name}&#34;</code></pre>
</details>
</dd>
<dt id="csvms.table.Table.location"><code class="name">var <span class="ident">location</span> : str</code></dt>
<dd>
<div class="desc"><p>Return table location on file system as string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def location(self) -&gt; str:
    &#34;&#34;&#34;Return table location on file system as string&#34;&#34;&#34;
    return f&#34;{self.database.location}/{self.name}.{Table._FORMAT_}&#34;</code></pre>
</details>
</dd>
<dt id="csvms.table.Table.transaction_log"><code class="name">var <span class="ident">transaction_log</span> : pathlib.Path</code></dt>
<dd>
<div class="desc"><p>Path to transaction log</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def transaction_log(self) -&gt; Path:
    &#34;&#34;&#34;Path to transaction log&#34;&#34;&#34;
    return Path(f&#34;{Database.FILE_DIR}/log/{self.full_name}&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="csvms.table.Table.alter"><code class="name flex">
<span>def <span class="ident">alter</span></span>(<span>self, option: str, column: Dict[str, type], new: Dict[str, type] = None) ‑> <a title="csvms.table.Table" href="#csvms.table.Table">Table</a></span>
</code></dt>
<dd>
<div class="desc"><p>Alter table definitions
:param option: Accepts ADD, DROP and MODIFY
:param column: Where to apply alteration
:param new: New column definition. Only used on MODIFY operations. Default is None
:return: The new modified table</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def alter(self, option:str, column:Dict[str,type], new:Dict[str,type]=None) -&gt; &#34;Table&#34;:
    &#34;&#34;&#34;Alter table definitions
    :param option: Accepts ADD, DROP and MODIFY
    :param column: Where to apply alteration
    :param new: New column definition. Only used on MODIFY operations. Default is None
    :return: The new modified table
    &#34;&#34;&#34;
    for key, val in column.items():
        if option.upper() == &#34;ADD&#34;:
            return self._add_column_(key, val)
        if option.upper() == &#34;DROP&#34;:
            return self._drop_column_(key)
        if option.upper() == &#34;MODIFY&#34;:
            if new is None:
                raise ColumnException(&#34;Need to inform new column definition&#34;)
            return self._modify_column_(key, new)
    raise ColumnException(f&#34;Column {column} not found&#34;)</code></pre>
</details>
</dd>
<dt id="csvms.table.Table.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, *values) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Add new row
:param values: list of values, separated by comma, to insert into
:return: True if table insertion was succeeded</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, *values) -&gt; bool:
    &#34;&#34;&#34;Add new row
    :param values: list of values, separated by comma, to insert into
    :return: True if table insertion was succeeded
    &#34;&#34;&#34;
    self._rows.append(self._validade_(values))
    self._redo_((&#39;I&#39;,(Table._op_ts_()))+tuple(values))
    log.info(&#34;Row inserted&#34;)
    return True</code></pre>
</details>
</dd>
<dt id="csvms.table.Table.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Remove all table data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self) -&gt; bool:
    &#34;&#34;&#34;Remove all table data&#34;&#34;&#34;
    self._rows = list()
    if exists(self.location):
        remove(self.location)
    if not self.temporary:
        Path(self.location).touch()
    return True</code></pre>
</details>
</dd>
<dt id="csvms.table.Table.drop"><code class="name flex">
<span>def <span class="ident">drop</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Remove physical file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drop(self) -&gt; bool:
    &#34;&#34;&#34;Remove physical file&#34;&#34;&#34;
    remove(self.location)
    del self.database.catalog[self.full_name]
    return True</code></pre>
</details>
</dd>
<dt id="csvms.table.Table.extend"><code class="name flex">
<span>def <span class="ident">extend</span></span>(<span>self, row: dict, ast: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Resolve functions recursively
:param ast: parsed expression
:return: Calculated value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extend(self, row:dict, ast:dict):
    &#34;&#34;&#34; Resolve functions recursively
    :param ast: parsed expression
    :return: Calculated value
    &#34;&#34;&#34;
    if isinstance(ast, dict):
        for key, val in ast.items():
            _x_, _y_ = val
            if isinstance(_x_, dict):
                if _x_.get(&#39;literal&#39;) is None:
                    _x_ = self.extend(row, _x_)
                else:
                    _x_ = _x_[&#39;literal&#39;]
            if isinstance(_y_, dict):
                if _y_.get(&#39;literal&#39;) is None:
                    _y_ = self.extend(row, _y_)
                else:
                    _y_ = _y_[&#39;literal&#39;]
            return Table.functions[key](self._value_(row,_x_),self._value_(row,_y_))
    return ast</code></pre>
</details>
</dd>
<dt id="csvms.table.Table.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>self) ‑> List[tuple]</span>
</code></dt>
<dd>
<div class="desc"><p>Load csv file from path with column formats
:param table_id: Table full name
:return: Tuple iterator</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load(self) -&gt; List[tuple]:
    &#34;&#34;&#34;Load csv file from path with column formats
    :param table_id: Table full name
    :return: Tuple iterator
    &#34;&#34;&#34;
    definition = self.database.catalog[self.full_name]
    self.columns = {key:Table.dtypes[value] for key, value in definition[&#34;columns&#34;].items()}
    with open(self.location, mode=&#39;r&#39;, encoding=&#34;utf-8&#34;) as csv_file:
        for raw in reader(csv_file, delimiter=Table._CSVSEP_):
            row = list()
            for idx, col in enumerate(self.columns.values()):
                row.append(col(raw[idx]))
            yield tuple(row)</code></pre>
</details>
</dd>
<dt id="csvms.table.Table.logical_evaluation"><code class="name flex">
<span>def <span class="ident">logical_evaluation</span></span>(<span>self, row: dict, ast: dict) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Recursively evaluate conditions
:param ast: Abstract Syntax Tree
:return: Boolean result</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def logical_evaluation(self, row:dict, ast:dict) -&gt; bool:
    &#34;&#34;&#34;Recursively evaluate conditions
    :param ast: Abstract Syntax Tree
    :return: Boolean result
    &#34;&#34;&#34;
    if isinstance(ast, dict):
        for key, val in ast.items():
            if key in [&#39;missing&#39;,&#39;exists&#39;]:
                return Table.operations[key](self._value_(row,val))
            if len(val)&gt;2: # Multiple conditions with and/or
                return self.logical_evaluation(row, {key:[val[-2],val[-1]]})
            _x_, _y_ = val
            if isinstance(_x_, dict):
                if _x_.get(&#39;literal&#39;) is None:
                    _x_ = self.logical_evaluation(row, _x_)
                else:
                    _x_ = _x_[&#39;literal&#39;]
            if isinstance(_y_, dict):
                if _y_.get(&#39;literal&#39;) is None:
                    _y_ = self.logical_evaluation(row, _y_)
                else:
                    _y_ = _y_[&#39;literal&#39;]
            return Table.operations[key](self._value_(row,_x_),self._value_(row,_y_))
    raise DataException(f&#34;Can&#39;t evaluate expression: {ast}&#34;)</code></pre>
</details>
</dd>
<dt id="csvms.table.Table.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Write data to file system</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self) -&gt; bool:
    &#34;&#34;&#34;Write data to file system&#34;&#34;&#34;
    if self.temporary:
        raise TableException(&#34;Can&#39;t save temporary tables&#34;)
    with open(self.location, mode=&#39;w&#39;, encoding=&#34;utf-8&#34;) as csv_file:
        csv_writer = writer(csv_file, delimiter=Table._CSVSEP_, quotechar=&#39;&#34;&#39;)
        for row in self._rows:
            csv_writer.writerow(row)
    self.database.catalog[self.full_name] = self.definition
    return True</code></pre>
</details>
</dd>
<dt id="csvms.table.Table.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>self, size: int = 20, trunc: bool = True) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Print as pretty table data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show(self, size:int=20, trunc:bool=True) -&gt; str:
    &#34;&#34;&#34;Print as pretty table data&#34;&#34;&#34;
    # Ugly code for a pretty table...
    idx_pad = 3
    # Max size of each column
    col_size = dict()
    for _c_ in self.columns:
        col_size[_c_]=len(_c_)+1
        for idx, _ in enumerate(self):
            cols = len(str(self[idx][_c_]))
            if col_size[_c_] &lt; cols:
                col_size[_c_]= cols
    # Table line separator
    sep = f&#34;{&#39; &#39;:{&#39;&gt;&#39;}{idx_pad}}+&#34;
    for key in self.columns.keys():
        sep += f&#34;{&#39;-&#39;:{&#39;-&#39;}{&#39;&lt;&#39;}{col_size[key]}}+&#34;
    # Table header
    col = f&#34;{&#39; &#39;:{&#39;&gt;&#39;}{idx_pad}}|&#34;
    for key in self.columns.keys():
        if trunc:
            col += f&#34;{key.split(&#39;.&#39;)[-1]:{&#39;&lt;&#39;}{col_size[key]}}|&#34;
        else:
            col += f&#34;{key:{&#39;&lt;&#39;}{col_size[key]}}|&#34;
    # Table rows
    rows = str()
    if len(self) &lt;= size:
        size = len(self)
        for idx in range(size):
            rows += f&#34;{idx:{&#39;&#39;}{&#39;&gt;&#39;}{idx_pad}}|&#34;
            for key, val in self[idx].items():
                rows += f&#34;{str(val):{&#39;&gt;&#39;}{col_size[key]}}|&#34;
            rows+=&#39;\n&#39;
    else:
        for idx in range(int(size/2)):
            rows += f&#34;{idx:{&#39;&#39;}{&#39;&gt;&#39;}{idx_pad}}|&#34;
            for key, val in self[idx].items():
                rows += f&#34;{str(val):{&#39;&gt;&#39;}{col_size[key]}}|&#34;
            rows+=&#39;\n&#39;
        # Separator row,
        rows += f&#34;{&#39; &#39;:{&#39;&gt;&#39;}{idx_pad}}|&#34;
        for key in self.columns.keys():
            rows += f&#34;{&#39;...&#39;:{&#39;&#39;}{&#39;&gt;&#39;}{col_size[key]}}|&#34;
        rows+=&#39;\n&#39;
        #reversed rows
        for idx in reversed(range(int(size/2))):
            _idx = len(self)-idx-1
            rows += f&#34;{_idx:{&#39;&#39;}{&#39;&gt;&#39;}{idx_pad}}|&#34;
            for key, val in self[_idx].items():
                rows += f&#34;{str(val):{&#39;&gt;&#39;}{col_size[key]}}|&#34;
            rows+=&#39;\n&#39;
    tbl = f&#34;TABLE: {self.full_name}\n&#34;
    if len(rows)&gt;0:
        return f&#34;&#34;&#34;{tbl}{sep}\n{col}\n{sep}\n{rows[:-1]}\n{sep}\n&#34;&#34;&#34;
    return f&#34;&#34;&#34;{tbl}{sep}\n{col}\n{sep}\n{sep}\n&#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="csvms.table.Table.Π"><code class="name flex">
<span>def <span class="ident">Π</span></span>(<span>self, extend: dict, alias: str = None) ‑> <a title="csvms.table.Table" href="#csvms.table.Table">Table</a></span>
</code></dt>
<dd>
<div class="desc"><p>Extended projection Operator (Π)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Π(self, extend:dict, alias:str=None) -&gt; &#34;Table&#34;:
    &#34;&#34;&#34;Extended projection Operator (Π)&#34;&#34;&#34;
    rows = list() # New list of rows
    dtype = None # Use to store the data type of the new extended column
    for idx, row in enumerate(self): # For each row
        val = self.extend(self[idx],extend) # Evaluated expression
        if dtype is None: # If is the first evaluation
            dtype = type(val) # Use the result data type
        # if you find any different type in the next rows
        elif dtype != type(val) and val is not None:
            # Raise an Data exeption to abort the operation
            raise DataException(f&#34;{type(val)} error&#34;)
        # If Successful add new value to the row tuple
        rows.append(row + (val,))
    # Copy the columns from source table
    cols = {k:v for k,v in self.columns.items()}
    # Add new extended column
    if alias is None: # Remova some characters and use the expression as column name
        cols[f&#34;{str(extend).replace(&#39; &#39;,&#39;&#39;).replace(&#39;.&#39;,&#39;,&#39;)}&#34;]=dtype
    else: # Use alias for the new extended column
        cols[alias]=dtype
    return Table(
        name = f&#34;({self.name}Π)&#34;,
        columns=cols,
        data=rows)</code></pre>
</details>
</dd>
<dt id="csvms.table.Table.π"><code class="name flex">
<span>def <span class="ident">π</span></span>(<span>self, select: list) ‑> <a title="csvms.table.Table" href="#csvms.table.Table">Table</a></span>
</code></dt>
<dd>
<div class="desc"><p>Projection Operator (π)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def π(self, select:list) -&gt; &#34;Table&#34;:
    &#34;&#34;&#34;Projection Operator (π)&#34;&#34;&#34;
    # Create a list of projected columns and your index
    cols = {k:v for k,v in self.columns.items()}
    rows = [v for v in self]
    if select != &#39;*&#39;: #In case of &#39;*&#39; return all columns
        if not isinstance(select, list):
            raise NotImplementedError
        _tc = list() # List of orderd columns and indexes
        for col in select:
            # Get column index
            for _i_,_c_ in enumerate(self.columns.keys()):
                if col[&#39;value&#39;]==_c_: #When find the column
                    _a_ = _c_
                    if col.get(&#39;name&#39;) is not None:
                        _a_ = col[&#39;name&#39;]
                    _tc.append((_i_,_c_,_a_)) #Add to the list with the index
                    break #Exit from loop when find
                elif col.get(&#39;name&#39;)==_c_:
                    _a_ = _c_ = col[&#39;name&#39;]
                    _tc.append((_i_,_c_,_a_)) #Add to the list with the index
        if len(_tc)!=len(select):
            raise ColumnException(&#34;Cant find all columns&#34;)
        rows = list()
        for row in self: # For each row
            _r_ = tuple() # Create a new tuple
            for idx,_,_ in _tc: # For each projected column
                _r_ += (row[idx],) # Add values for projected column index
            rows.append(_r_) # Append the new sub tuple to the new list of rows
        cols = {a:self.columns[k] for _,k,a in _tc}
    return Table(name=f&#34;({self.name}π)&#34;,columns=cols,data=rows)</code></pre>
</details>
</dd>
<dt id="csvms.table.Table.ρ"><code class="name flex">
<span>def <span class="ident">ρ</span></span>(<span>self, alias: str) ‑> <a title="csvms.table.Table" href="#csvms.table.Table">Table</a></span>
</code></dt>
<dd>
<div class="desc"><p>Rename Operator (ρ)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ρ(self, alias:str) -&gt; &#34;Table&#34;:
    &#34;&#34;&#34;Rename Operator (ρ)&#34;&#34;&#34;
    # Function to rename column names for the new table name
    rename = lambda x: x if x.count(&#39;.&#39;)==0 else x.split(&#39;.&#39;)[-1]
    return Table(
        # Set new table name
        name = f&#34;{alias}&#34;,
        # Copy all columns from source table
        columns={rename(k):v for k,v in self.columns.items()},
        # Copy all rows from source table
        data=[r for r in self])</code></pre>
</details>
</dd>
<dt id="csvms.table.Table.σ"><code class="name flex">
<span>def <span class="ident">σ</span></span>(<span>self, condition: Dict[str, list], null=False) ‑> <a title="csvms.table.Table" href="#csvms.table.Table">Table</a></span>
</code></dt>
<dd>
<div class="desc"><p>Selection Operator (σ)
:param condition: A expression composed by the logic operation and list of values.
See 'operations' dictionary to get the list of valid options</p>
<h3 id="exemples">Exemples</h3>
<p>where id &lt; 2
<code>where({'lt':['id',2]})</code></p>
<p>where val = 'George' and id &gt; 1
<code>where({'and':[{"eq":['val','George']},{"gt":['id',1]}]})</code></p>
<h3 id="operations">Operations</h3>
<p>List of supported operations and the logical equivalent python evaluation</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Python eval</th>
</tr>
</thead>
<tbody>
<tr>
<td>lt</td>
<td>&lt;</td>
</tr>
<tr>
<td>gt</td>
<td>&gt;</td>
</tr>
<tr>
<td>eq</td>
<td>==</td>
</tr>
<tr>
<td>lte</td>
<td>&lt;=</td>
</tr>
<tr>
<td>gte</td>
<td>&gt;=</td>
</tr>
<tr>
<td>neq</td>
<td>!=</td>
</tr>
<tr>
<td>is</td>
<td>is</td>
</tr>
<tr>
<td>in</td>
<td>in</td>
</tr>
<tr>
<td>nin</td>
<td>not in</td>
</tr>
<tr>
<td>or</td>
<td>or</td>
</tr>
<tr>
<td>and</td>
<td>and</td>
</tr>
<tr>
<td>missing</td>
<td>is None</td>
</tr>
<tr>
<td>exists</td>
<td>is not None</td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def σ(self, condition:Dict[str,list], null=False) -&gt; &#34;Table&#34;:
    &#34;&#34;&#34;Selection Operator (σ)
    :param condition: A expression composed by the logic operation and list of values.
                      See &#39;operations&#39; dictionary to get the list of valid options
    ### Exemples

    where id &lt; 2
    `where({&#39;lt&#39;:[&#39;id&#39;,2]})`

    where val = &#39;George&#39; and id &gt; 1
    `where({&#39;and&#39;:[{&#34;eq&#34;:[&#39;val&#39;,&#39;George&#39;]},{&#34;gt&#34;:[&#39;id&#39;,1]}]})`

    ### Operations
    List of supported operations and the logical equivalent python evaluation

    | Name    | Python eval |
    |---------|-------------|
    | lt      | &lt;           |
    | gt      | &gt;           |
    | eq      | ==          |
    | lte     | &lt;=          |
    | gte     | &gt;=          |
    | neq     | !=          |
    | is      | is          |
    | in      | in          |
    | nin     | not in      |
    | or      | or          |
    | and     | and         |
    | missing | is None     |
    | exists  | is not None |

    &#34;&#34;&#34;
    rows = list()
    for idx, row in enumerate(self):
        if self.logical_evaluation(self[idx], condition):
            rows.append(row)
    if null and len(rows)==0:
        rows.append(self.empty_row)
    return Table(
        name = f&#34;({self.name}σ)&#34;,
        columns={k:v for k,v in self.columns.items()},
        data=rows)</code></pre>
</details>
</dd>
<dt id="csvms.table.Table.ᐅᐊ"><code class="name flex">
<span>def <span class="ident">ᐅᐊ</span></span>(<span>self, other: <a title="csvms.table.Table" href="#csvms.table.Table">Table</a>, where: Dict[str, list]) ‑> <a title="csvms.table.Table" href="#csvms.table.Table">Table</a></span>
</code></dt>
<dd>
<div class="desc"><p>Join Operator (⋈)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ᐅᐊ(self, other:&#34;Table&#34;, where:Dict[str,list]) -&gt; &#34;Table&#34;:
    &#34;&#34;&#34;Join Operator (⋈)&#34;&#34;&#34;
    # Create a new table with the Cartesian product of self and otther
    tbl = (self * other)\
        .σ(where) # And select rows where the join condition is true
    tbl.name = f&#34;({self.name}⋈{other.name})&#34;
    return tbl</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="csvms" href="index.html">csvms</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="csvms.table.rnm" href="#csvms.table.rnm">rnm</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="csvms.table.Table" href="#csvms.table.Table">Table</a></code></h4>
<ul class="two-column">
<li><code><a title="csvms.table.Table.alter" href="#csvms.table.Table.alter">alter</a></code></li>
<li><code><a title="csvms.table.Table.append" href="#csvms.table.Table.append">append</a></code></li>
<li><code><a title="csvms.table.Table.clean" href="#csvms.table.Table.clean">clean</a></code></li>
<li><code><a title="csvms.table.Table.definition" href="#csvms.table.Table.definition">definition</a></code></li>
<li><code><a title="csvms.table.Table.drop" href="#csvms.table.Table.drop">drop</a></code></li>
<li><code><a title="csvms.table.Table.dtypes" href="#csvms.table.Table.dtypes">dtypes</a></code></li>
<li><code><a title="csvms.table.Table.empty_row" href="#csvms.table.Table.empty_row">empty_row</a></code></li>
<li><code><a title="csvms.table.Table.extend" href="#csvms.table.Table.extend">extend</a></code></li>
<li><code><a title="csvms.table.Table.full_name" href="#csvms.table.Table.full_name">full_name</a></code></li>
<li><code><a title="csvms.table.Table.functions" href="#csvms.table.Table.functions">functions</a></code></li>
<li><code><a title="csvms.table.Table.load" href="#csvms.table.Table.load">load</a></code></li>
<li><code><a title="csvms.table.Table.location" href="#csvms.table.Table.location">location</a></code></li>
<li><code><a title="csvms.table.Table.logical_evaluation" href="#csvms.table.Table.logical_evaluation">logical_evaluation</a></code></li>
<li><code><a title="csvms.table.Table.operations" href="#csvms.table.Table.operations">operations</a></code></li>
<li><code><a title="csvms.table.Table.save" href="#csvms.table.Table.save">save</a></code></li>
<li><code><a title="csvms.table.Table.show" href="#csvms.table.Table.show">show</a></code></li>
<li><code><a title="csvms.table.Table.transaction_log" href="#csvms.table.Table.transaction_log">transaction_log</a></code></li>
<li><code><a title="csvms.table.Table.Π" href="#csvms.table.Table.Π">Π</a></code></li>
<li><code><a title="csvms.table.Table.π" href="#csvms.table.Table.π">π</a></code></li>
<li><code><a title="csvms.table.Table.ρ" href="#csvms.table.Table.ρ">ρ</a></code></li>
<li><code><a title="csvms.table.Table.σ" href="#csvms.table.Table.σ">σ</a></code></li>
<li><code><a title="csvms.table.Table.ᐅᐊ" href="#csvms.table.Table.ᐅᐊ">ᐅᐊ</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>